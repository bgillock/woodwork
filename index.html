<html lang="en">

<head>
    <title>three.js webgl - interactive - voxel painter</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
        
        #oldie {
            background-color: #ddd !important
        }
    </style>
</head>

<body>

    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="face.js"></script>
    <script src="piece.js"></script>
    <script>
        var container;
        var camera, scene, renderer;
        var plane, cube;
        var mouse, raycaster, isShiftDown = false;
        var rollOverPiece, rollOverMaterial;
        var rollOverVertices;
        var cubeGeo, cubeMaterial;
        var currentPiece = ""
        var objects = []
        var pieces = []
        var defaultPieceShape = new THREE.Vector3(250, 75, 100)

        if (!Detector.webgl) Detector.addGetWebGLMessage();

        init();
        render();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
            var info = document.createElement('div');
            info.style.position = 'absolute';
            info.style.top = '10px';
            info.style.width = '100%';
            info.style.textAlign = 'center';
            info.innerHTML = 'Wood Worker<br><strong>click</strong>: add piece, <strong>shift + click</strong>: remove piece';
            container.appendChild(info);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(500, 800, 1300);
            camera.lookAt(new THREE.Vector3());
            scene = new THREE.Scene();
            
            // piece to use for showing potential placement
            var centerPoint = new THREE.Vector3(0,0,0)
            rollOverPiece = new Piece(centerPoint.divideScalar(50).floor().multiplyScalar(50),
                                  defaultPieceShape,false)
            rollOverMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                opacity: 0.5,
                transparent: true,
                // side: THREE.DoubleSide,
            });
            
            // grid
            var gridHelper = new THREE.GridHelper(1000, 20);
            scene.add(gridHelper);
            //
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            var geometry = new THREE.PlaneBufferGeometry(1000, 1000);
            geometry.rotateX(-Math.PI / 2);
            plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
                visible: false
            }));
            scene.add(plane);
            objects.push(plane);
            // Lights
            var ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            var directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(1, 0.75, 0.5).normalize();
            scene.add(directionalLight);
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            var controls = new THREE.OrbitControls(camera, renderer.domElement);

            container.appendChild(renderer.domElement);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('keydown', onDocumentKeyDown, false);
            document.addEventListener('keyup', onDocumentKeyUp, false);
            //document.addEventListener('wheel', onMouseWheel, false);
            //
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                var intersect = intersects[0];
                if (intersect.object != plane) {
                    // highlight the piece we intersected with
                    if (currentPiece != "") currentPiece.unhighlight()
                    currentPiece = intersect.object.userData
                    currentPiece.highlight()
                    scene.remove(rollOverPiece.group)
                } else {
                    // show the rollOverPiece where it would be placed if he clicked
                    var point = new THREE.Vector3(intersect.point.x,intersect.point.y,intersect.point.z)
                    
                    point.divideScalar(50).floor().multiplyScalar(50);
                    rollOverPiece.position(point)
                    scene.add(rollOverPiece.group)
                    if (currentPiece != "") currentPiece.unhighlight()
                    currentPiece = ""
                }
            }
            else
            {
                scene.remove(rollOverPiece.group)
            }
            render();
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                var intersect = intersects[0];
                // delete board
                if (isShiftDown) {
                    if (intersect.object != plane) {
                        if (intersect.object.userData) intersect.object.userData.remove()  
                    }
                    // create board
                } else {
                    var point = intersect.point;
                    var board = new Piece(point.divideScalar(50).floor().multiplyScalar(50),
                        defaultPieceShape)
                    pieces.push(board)
                }
                render();
            }
        }

        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 16:
                    isShiftDown = true;
                    break;
            }
        }

        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 16:
                    isShiftDown = false;
                    break;
                case 37: // left arrow
                    break;
                case 38: // up arrow
                    break;
                case 39: // right arrow
                    break;
                case 40: // down arrow
                    break;                                                           
            }
            
        }
        function onMouseWheel(event) {
            render()
        }
        function render() {
            renderer.render(scene, camera);
        }
    </script>

</body>

</html>