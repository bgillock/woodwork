<html lang="en">

<head>
    <title>three.js webgl - interactive - voxel painter</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
        
        #oldie {
            background-color: #ddd !important
        }
    </style>
</head>
<style>
    html,
    body {
        height: 100%;
        margin: 0;
        padding: 0;
    }
    
    #scene {
        width: 400px;
        height: 400px;
        border: 3px solid green;
        float: left;
        margin-left: 5px;
        margin-top: 0px
    }
    
    #editscene {
        width: 100px;
        height: 400px;
        border: 3px solid red;
        margin-left: 417px;
        margin-top: 5px
    }
    
    #cutview {
        width: 512px;
        height: 200px;
        border: 3px solid blue;
        margin: 5px;
        clear: both;
    }
    
    #editcut {
        width: 512px;
        height: 100px;
        border: 3px solid yellow;
        margin: 5px;
        clear: both;
    }
</style>
</head>
<div id="assembly"></div>
<div id="editscene"></div>
<div id="cutview"></div>
<div id="editcut"></div>

<body>

    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="face.js"></script>
    <script src="piece.js"></script>
    <script>
        var assembly;
        var STATE = {
            NONE: -1,
            CAMERA: 0,
            SELECT: 1,
            MOVE: 2
        };
        var state = STATE.NONE;
        var camera, scene, renderer, controls;
        var gridGeometry
        var plane, cube;
        var mouse, raycaster, isShiftDown = false;
        var isControlDown = false
        var selectionPiece, rollOverMaterial;
        var rollOverVertices;
        var cubeGeo, cubeMaterial;
        var currentPiece = ""
        var objects = []
        var pieces = []
        var defaultPieceShape = new THREE.Vector3(250, 75, 100)

        if (!Detector.webgl) Detector.addGetWebGLMessage();

        init();
        render();

        function init() {
            assembly = document.getElementById('assembly')
            camera = new THREE.PerspectiveCamera(45, assembly.clientWidth / assembly.clientHeight, 1, 10000);
            camera.position.set(500, 800, 1300);
            camera.lookAt(new THREE.Vector3());
            scene = new THREE.Scene();

            // piece to use for showing potential placement
            var centerPoint = new THREE.Vector3(0, 0, 0)
            defaultPiece = new Piece(centerPoint.divideScalar(50).floor().multiplyScalar(50),
                defaultPieceShape, false)
            selectionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                opacity: 0.5,
                transparent: true,
                // side: THREE.DoubleSide,
            });

            // grid
            var gridHelper = new THREE.GridHelper(1000, 20);
            scene.add(gridHelper);
            //
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            gridGeometry = new THREE.PlaneBufferGeometry(1000, 1000);
            gridGeometry.rotateX(-Math.PI / 2);
            gridGeometry.computeBoundingBox()
            plane = new THREE.Mesh(gridGeometry, new THREE.MeshBasicMaterial({
                visible: false
            }));
            scene.add(plane);
            objects.push(plane);
            // Lights
            var ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            var directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(1, 0.75, 0.5).normalize();
            scene.add(directionalLight);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(assembly.clientWidth, assembly.clientHeight);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false
            assembly.appendChild(renderer.domElement);
            assembly.style.cursor = 'auto';
            assembly.addEventListener('mousemove', onAssemblyMouseMove, false);
            assembly.addEventListener('mousedown', onAssemblyMouseDown, false);
            assembly.addEventListener('mouseup', onAssemblyMouseUp, false);
            document.addEventListener('keydown', onAssemblyKeyDown, false);
            document.addEventListener('keyup', onAssemblyKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = assembly.clientWidth / assembly.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(assembly.clientWidth, assembly.clientHeight);
        }

        function selectPiece(piece) {
            state = STATE.SELECT
            selectedPiece = piece
            selectedPiece.highlight()
            assembly.style.cursor = 'pointer';
        }

        function unselectPiece(piece) {
            state = STATE.NONE
            selectedPiece.unhighlight()
            selectedPiece = null
            assembly.style.cursor = 'auto';
        }

        function handleMouseDown(event) {
            switch (state) {
                case STATE.NONE:
                    var intersect = getIntersect(event)

                    if (intersect.object != plane) {
                        // clicked on an existing object
                        selectPiece(intersect.object.userData)
                    } else {
                        // create new pience
                        var point = intersect.point;
                        point.y = Math.max(point.y, 0)
                        if (defaultPiece.canPlace(point)) {
                            var newPiece = new Piece(point, defaultPieceShape)
                            selectPiece(newPiece)
                        }
                    }
                    render();
                    break;
                case STATE.SELECT:
                    var intersect = getIntersect(event)
                    if (intersect == null) break
                    if ((intersect.object != plane) &&
                        (intersect.object.userData == selectedPiece)) {
                        state = STATE.MOVE
                        assembly.style.cursor = 'move'
                        selectedPiece.remove() // from hit testing
                        handleMouseMovePiece(event)
                    } else {
                        // create new pience
                        var point = intersect.point;
                        point.y = Math.max(point.y, 0)
                        if (defaultPiece.canPlace(point)) {
                            var newPiece = new Piece(point, defaultPieceShape)
                            if (selectedPiece != null) selectedPiece.unhighlight()
                            selectPiece(newPiece)
                        }
                    }
                    break;
            }
        }

        function handleMouseUp(event) {
            switch (state) {
                case STATE.MOVE:
                    state = STATE.SELECT
                    selectedPiece.add()
                    break
            }
        }

        function handleMouseMovePiece(event) {
            var intersect = getIntersect(event)
            if (intersect == null) return
            /// TODO: Snap to a face of another object
            var point = new THREE.Vector3(intersect.point.x, intersect.point.y, intersect.point.z)
            point.y = Math.max(point.y, 0)
            if (selectedPiece.canPlace(point)) {
                selectedPiece.position(point)
            }
        }

        function onAssemblyMouseDown(event) {
            if (isControlDown) return
            event.preventDefault();
            switch (event.button) {
                case THREE.MOUSE.LEFT:
                    handleMouseDown(event);
                    break;
            }
            render()
        }

        function getIntersect(event) {
            mouse.set((event.clientX / assembly.clientWidth) * 2 - 1, -(event.clientY / assembly.clientHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                return intersects[0]
            }
            return null
        }

        function onAssemblyMouseMove(event) {
            if (isControlDown) return
            event.preventDefault();
            switch (state) {
                case STATE.MOVE:
                    handleMouseMovePiece(event);
                    break
                case STATE.NONE:
                    var intersect = getIntersect(event)
                    if (intersect == null) break
                    if (intersect.object != plane) {
                        assembly.style.cursor = 'pointer';
                    } else {
                        assembly.style.cursor = 'auto';
                    }
                    break
                case STATE.SELECT:
                    var intersect = getIntersect(event)
                    if (intersect == null) {
                        break
                    }
                    if (intersect.object == plane) {
                        assembly.style.cursor = 'auto';
                        break
                    }
                    if (intersect.object.userData != selectedPiece) {
                        assembly.style.cursor = 'pointer';
                    } else {
                        assembly.style.cursor = 'move';
                    }
                    break
            }
            render()
        }

        function onAssemblyMouseUp(event) {
            if (isControlDown) return
            handleMouseUp(event);
        }
        var lastCursor = null
        function onAssemblyKeyDown(event) {
            switch (event.keyCode) {
                case 16:
                    isShiftDown = true
                    break
                case 17:
                    isControlDown = true
                    lastCursor = assembly.style.cursor
                    assembly.style.cursor = '-webkit-grab';    
                    controls.enabled = true
                    break
            }
            
        }

        function onAssemblyKeyUp(event) {
            switch (event.keyCode) {
                case 8: // delete
                    if (selectionMade) {
                        selectedPiece.remove()
                    }
                    break
                case 16: // shift
                    isShiftDown = false
                    break
                case 17: // control
                    isControlDown = false
                    controls.enabled = false
                    assembly.style.cursor = lastCursor
                    break
                case 27: // esc
                    if (state == STATE.MOVE) {
                        state = STATE.SELECT
                    }
                    if (state == STATE.SELECT) {
                        state = state.NONE
                    }
                    break
                case 37: // left arrow
                    break
                case 38: // up arrow
                    break
                case 39: // right arrow
                    break
                case 40: // down arrow
                    break;
            }
            render()
        }

        function onMouseWheel(event) {
            console.log("onMouseWheel(index)")

            render()
        }

        function render() {
            console.log(state)
            renderer.render(scene, camera);
        }
    </script>

</body>

</html>