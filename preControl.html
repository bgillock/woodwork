<html lang="en">

<head>
    <title>three.js webgl - interactive - voxel painter</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
        
        #oldie {
            background-color: #ddd !important
        }
    </style>
</head>

<body>

    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/Detector.js"></script>
    <script src="face.js"></script>
    <script src="piece.js"></script>
    <script>
        var container;
        var camera, scene, renderer, controls;
        var gridGeometry
        var plane, cube;
        var mouse, raycaster, isShiftDown = false;
        var isControlDown = false
        var selectionMade = false
        var selectionPiece, rollOverMaterial;
        var rollOverVertices;
        var cubeGeo, cubeMaterial;
        var currentPiece = ""
        var objects = []
        var pieces = []
        var defaultPieceShape = new THREE.Vector3(250, 75, 100)

        if (!Detector.webgl) Detector.addGetWebGLMessage();

        init();
        render();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);
            var info = document.createElement('div');
            info.style.position = 'absolute';
            info.style.top = '10px';
            info.style.width = '100%';
            info.style.textAlign = 'center';
            info.innerHTML = 'Wood Worker<br><strong>click</strong>: add piece, <strong>shift + click</strong>: remove piece';
            container.appendChild(info);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(500, 800, 1300);
            camera.lookAt(new THREE.Vector3());
            scene = new THREE.Scene();

            // piece to use for showing potential placement
            var centerPoint = new THREE.Vector3(0, 0, 0)
            defaultPiece = new Piece(centerPoint.divideScalar(50).floor().multiplyScalar(50),
                defaultPieceShape, false)
            selectionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                opacity: 0.5,
                transparent: true,
                // side: THREE.DoubleSide,
            });

            // grid
            var gridHelper = new THREE.GridHelper(1000, 20);
            scene.add(gridHelper);
            //
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            gridGeometry = new THREE.PlaneBufferGeometry(1000, 1000);
            gridGeometry.rotateX(-Math.PI / 2);
            gridGeometry.computeBoundingBox()
            plane = new THREE.Mesh(gridGeometry, new THREE.MeshBasicMaterial({
                visible: false
            }));
            scene.add(plane);
            objects.push(plane);
            // Lights
            var ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            var directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(1, 0.75, 0.5).normalize();
            scene.add(directionalLight);
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enabled = false
            container.appendChild(renderer.domElement);
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('keydown', onDocumentKeyDown, false);
            document.addEventListener('keyup', onDocumentKeyUp, false);
            //document.addEventListener('wheel', onMouseWheel, false);
            //
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function selectPiece(piece) {
            selectionMade = true
            selectedPiece = piece
            selectedPiece.highlight()
        }

        function unselectPiece(piece) {
            selectionMade = false
            selectedPiece.unhighlight()
            selectedPiece = null
        }

        function onDocumentMouseMove(event) {
            if (isControlDown) return
            if (!selectionMade) return
            console.log("onDocumentMouseMove")
            event.preventDefault();
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                var intersect = intersects[0];
                if (intersect.object != plane) {
                    // highlight the piece we intersected with
                    if (currentPiece != "") currentPiece.unhighlight()
                    currentPiece = intersect.object.userData
                    currentPiece.highlight()
                    scene.remove(selectedPiece.group)
                    container.style.cursor = 'move';
                } else {
                    container.style.cursor = 'pointer';
                    // show the rollOverPiece where it would be placed if he clicked
                    var point = new THREE.Vector3(intersect.point.x, intersect.point.y, intersect.point.z)
                    point.y = Math.max(point.y, 0)
                    if (selectedPiece.canPlace(point)) {
                        var closeTo = selectedPiece.closeTo(objects, 50)
                        if (closeTo.object != null) {
                            container.style.cursor = 'pointer';
                        }
                        selectedPiece.position(point)
                        scene.add(selectedPiece.group)
                        if (currentPiece != "") currentPiece.unhighlight()
                        currentPiece = ""
                    } else {
                        scene.remove(selectedPiece.group)
                    }
                }
            } else {
                container.style.cursor = '-webkit-grab';
                scene.remove(selectedPiece.group)
            }
            render();
        }

        function onDocumentMouseDown(event) {
            if (isControlDown) return
                //console.log("onDocumentMouseDown")
            event.preventDefault();

            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(objects);
            if (intersects.length > 0) {
                var intersect = intersects[0];

                if (intersect.object != plane) {
                    selectPiece(intersect.object.userData)
                } else {
                    if (!selectionMade) {
                        // create board
                        var point = intersect.point;
                        point.y = Math.max(point.y, 0)
                        if (defaultPiece.canPlace(point)) {
                            var newPiece = defaultPiece
                            selectPiece(newPiece)
                        }
                    } else {

                    }
                }
                render();
            }
        }

        function onDocumentKeyDown(event) {
            //console.log("onDocumentKeyDown")
            switch (event.keyCode) {
                case 16:
                    isShiftDown = true
                    break
                case 17:
                    isControlDown = true
                    controls.enabled = true
                    break
            }
        }

        function onDocumentKeyUp(event) {
            console.log("onDocumentKeyUp")

            switch (event.keyCode) {
                case 8: // delete
                    if (selectionMade) {
                        selectedPiece.remove()
                    }
                    break
                case 16: // shift
                    isShiftDown = false
                    break
                case 17: // control
                    isControlDown = false
                    controls.enabled = false
                    break
                case 37: // left arrow
                    break
                case 38: // up arrow
                    break
                case 39: // right arrow
                    break
                case 40: // down arrow
                    break;
            }

        }

        function onMouseWheel(event) {
            console.log("onMouseWheel(index)")

            render()
        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>

</body>

</html>