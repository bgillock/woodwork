<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<button id="pressMe" style="position: absolute;">
  PressMe
</button>
<script>
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
camera.position.set(0, 10, 50);
var renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

var controls = new THREE.OrbitControls(camera, renderer.domElement);

scene.add(new THREE.AxisHelper(2));

var planeGeom = new THREE.PlaneGeometry(30, 30);
planeGeom.rotateX(-Math.PI / 2);
var plane = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({
  color: "pink",
  transparent: true,
  opacity: 0.5,
  side: THREE.DoubleSide
}));
plane.position.y = -3.14;
//plane.rotation.x = Math.PI / 5;
scene.add(plane);

var objGeom = new THREE.TorusKnotGeometry(10,3);
objGeom.computeFaceNormals();
objGeom.computeVertexNormals();
var obj = new THREE.Mesh(objGeom, new THREE.MeshBasicMaterial({
  color: 0x00ff00,
  wireframe: true
}));
obj.rotation.z = Math.PI / 10;
obj.position.set(0, 3.14, 0);
scene.add(obj);

pressMe.addEventListener("click", drawIntersectionPoints, false);

var pOI = new THREE.Geometry();

var a = new THREE.Vector3(),
  b = new THREE.Vector3(),
  c = new THREE.Vector3();
var planePointA = new THREE.Vector3(),
  planePointB = new THREE.Vector3(),
  planePointC = new THREE.Vector3();
var lineAB = new THREE.Line3(),
  lineBC = new THREE.Line3(),
  lineCA = new THREE.Line3();

var pointOfIntersection = new THREE.Vector3();

function equals(a,b)
{
    if ((Math.abs(a.x-b.x) < 0.0001) &&
        (Math.abs(a.y-b.y) < 0.0001) &&
        (Math.abs(a.z-b.z) < 0.0001)) { 
            return true
        }
    return false
}
function drawIntersectionPoints() {
  var mathPlane = new THREE.Plane();
  plane.localToWorld(planePointA.copy(plane.geometry.vertices[plane.geometry.faces[0].a]));
  plane.localToWorld(planePointB.copy(plane.geometry.vertices[plane.geometry.faces[0].b]));
  plane.localToWorld(planePointC.copy(plane.geometry.vertices[plane.geometry.faces[0].c]));
  mathPlane.setFromCoplanarPoints(planePointA, planePointB, planePointC);

  obj.geometry.faces.forEach(function(face) {
    obj.localToWorld(a.copy(obj.geometry.vertices[face.a]));
    obj.localToWorld(b.copy(obj.geometry.vertices[face.b]));
    obj.localToWorld(c.copy(obj.geometry.vertices[face.c]));
    lineAB = new THREE.Line3(a, b);
    lineBC = new THREE.Line3(b, c);
    lineCA = new THREE.Line3(c, a);
    setPointOfIntersection(lineAB, mathPlane);
    setPointOfIntersection(lineBC, mathPlane);
    setPointOfIntersection(lineCA, mathPlane);
  });

  var pointsMaterial = new THREE.PointsMaterial({
    size: .5,
    color: "yellow"
  });
  var points = new THREE.Points(pOI, pointsMaterial);
  scene.add(points);
  
  var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffff00 } );
  var line = new THREE.LineSegments( pOI, lineMaterial );
  scene.add( line );
  var triangles
  var holes = []
  var meshes = []
  var geom = new THREE.Geometry(); 
  geom.vertices.push(new THREE.Vector3(pOI.vertices[0].x,pOI.vertices[0].z,0 ));
  var material = new THREE.MeshBasicMaterial({
        color: 0x0000FF,
        wireframe: true
    })
  for(var p=2; p<pOI.vertices.length; p+=2){
    if (!(equals(pOI.vertices[p-1],pOI.vertices[p]) || 
          equals(pOI.vertices[p-2],pOI.vertices[p]) ||
          equals(pOI.vertices[p-1],pOI.vertices[p+1]) || 
         equals(pOI.vertices[p-2],pOI.vertices[p+1])))
    {

        triangles = THREE.ShapeUtils.triangulateShape( geom.vertices, holes );
        for( var i = 0; i < triangles.length; i++ ){
            geom.faces.push( new THREE.Face3( triangles[i][0], triangles[i][1], triangles[i][2] ));
        }
        var mesh = new THREE.Mesh( geom, material );
        meshes.push(mesh)
        scene.add(mesh)
        geom = new THREE.Geometry(); 
    }
    if (equals(pOI.vertices[p],pOI.vertices[p-2]) || 
        equals(pOI.vertices[p],pOI.vertices[p-1])) {
        geom.vertices.push(new THREE.Vector3(pOI.vertices[p+1].x,pOI.vertices[p+1].z,0 ))
    }
    else {
        geom.vertices.push(new THREE.Vector3(pOI.vertices[p].x,pOI.vertices[p].z,0 ))
    }
  }
  triangles = THREE.ShapeUtils.triangulateShape( geom.vertices, holes );
    for( var i = 0; i < triangles.length; i++ ){
        geom.faces.push( new THREE.Face3( triangles[i][0], triangles[i][1], triangles[i][2] ));
    }
    var mesh = new THREE.Mesh( geom, material );
    meshes.push(mesh)
    scene.add(mesh)
}

function setPointOfIntersection(line, plane) {
  pointOfIntersection = plane.intersectLine(line);
  if (pointOfIntersection) {
    pOI.vertices.push(pointOfIntersection.clone());
  };
}


render();

function render() {
  requestAnimationFrame(render);
  renderer.render(scene, camera);
}
</script>